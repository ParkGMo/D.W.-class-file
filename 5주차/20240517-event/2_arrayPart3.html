<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Array Part 3</title>
  </head>
  <body></body>
  <script>
    // 1. forEach() 함수 ⭐⭐⭐
    // 해당 배열의 모든 요소에 대하여 반복적으로 명시된 함수를 실행한다.
    document.write(`<h1>1. forEach() 함수 </h1>`);
    const arr = [1, true, "Javascript"];
    arr.push(5);
    /*
    function printArr( , , ) {}
    arr.forEach(printArr);
    -> 함수가 주어진다면 직접 파라미터에 적어도된다.

    arr.forEach(function( , , ){});
    -> 익명 함수를 직접 넣어주어도 된다.
    */
    function printArr(value, index, array) {
      console.log(`value : ${value}, index : ${index}, array : ${array}`);
    }
    // value, index, array 파라미터 내의 매개변수는 원하는 대로 지정가능 ex)x,y,z

    arr.forEach(printArr);
    // arr.forEach(printArr); 함수 자체를 의미한다.
    // arr.forEach(printArr()); 함수를 바로 실행 한다.
    console.log(typeof printArr);
    console.log(typeof printArr(arr));
    // console.log(typeof printArr); -> 함수라는 타입이 출력된다.
    // console.log(typeof printArr()); -> 함수의 값이 출력된다.

    // 2. map() 함수 ⭐⭐⭐⭐⭐
    // 해당 배열의 모든 요소에 대하여 반복적으로 명시된 함수를 실행한 후,
    // 그 결과를 새로운 배열에 담아 반환한다.
    const arr2 = [3, 4, 5, 6];
    const tempArr = [];
    // for (let i = 0; i < arr2.length; i++) {
    //   tempArr.push(arr2[i] * 2);
    // }
    // console.log(arr2);

    function arr3(el) {
      tempArr.push(el * 2);
    }
    arr2.forEach(arr3);
    console.log(tempArr);

    // let modifiedArr = [];
    // modifiedArr = arr2.map(function (elemnet, index, array) {
    //     return element * 2;
    // });
    let modifiedArr = arr2.map(function (v) {
      return v * 2;
    });
    // modifiedArr = arr2.map((v) => v * 2);
    console.log(modifiedArr);
    document.write(`<h1>2. map() 함수</h1>`);
    document.write(`<h3>arr2 : [${arr2}]</h3>`);
    document.write(`<h3>arr2의 원소에 * 2 : [${modifiedArr}]</h3>`);

    const users = [
      { firstname: "베컴", lastname: "데이비드" },
      { firstname: "더브라위너", lastname: "케빈" },
      { firstname: "홀란드", lastname: "엘링" },
    ];
    //["데이비드 베컴","케빈 더브라위너", "엘링 홀란드" ]
    const nameArr = users.map(function (v) {
      return ` ${v.lastname}  ${v.firstname} `;
    });
    document.write(`"${users}"`);
    document.write(`<br>`);
    document.write(`"${nameArr}"`);

    const numberArr = [1, 2, 3, 4, 5, 6, 7, 8, 10];
    function multiplyThree(number) {
      return number * 3;
    }
    // 단일 숫자 함수 활용
    document.write(`<h3>${multiplyThree(11)}</h3>`);

    // 배열의 숫자들 각각을 함수 실행!
    const newnumberArr = numberArr.map(multiplyThree);
    // const newnumberArr = numberArr.map(function(v){
    //     return v * 3;
    // });
    document.write(`<h3>${numberArr}</h3>`);
    document.write(`<h3>${newnumberArr}</h3>`);

    //practice1
    const doubleArr = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9],
    ];
    // [6, 15, 24] 각 배열을 전부 합한값 - 1 -> 배열 안 배열의 수가 홀수 개면 가능
    const newdoubleArr = doubleArr.map(function (v, i, a) {
      //   return v[0] + v[1] + v[2];
      return v[parseInt(a.length / 2)] * a.length;
    });

    // v = [1, 2, 3] i = 0
    // v = [4, 5, 6] i = 1
    // v = [7, 8, 9] i = 2

    document.write(`<h3>${newdoubleArr}</h3>`);

    // [6, 15, 24] 각 배열을 전부 합한값 - 2 -> 주어진 배열이 모른다는 가정을 할때
    function sum(array) {
      let sum = 0;
      for (let i = 0; i < array.length; i++) {
        sum += array[1];
      }
      return sum;
    }
    doubleArr.map(sum);

    document.write(`<h3>${doubleArr.map(sum)}</h3>`);

    // [0, 5, 10, 15]
    const numArr = [5, 10, 15, 20];
    const newnumArr = numArr.map(function (v, i, a) {
      //   return v - 5;
      //   return i * 5;
      //   return v - a.length - 1;
      return (a.length + 1) * i;
    });

    document.write(`<h3>${newnumArr}</h3>`);

    const strArr = ["apple", "banana", "watermelon"];
    // [5, 6, 10]

    const newArr = strArr.map(function (v, i, a) {
      return v.length;
    });

    document.write(`<h3>${newArr}</h3>`);

    // ["HELLO", "WORLD", "JAVASCRIPT"]
    const strArr2 = ["hello", "world", "Javascript"];
    const newArr2 = strArr2.map(function (v, i, a) {
      return `" ${v.toUpperCase()} "`;
    });
    document.write(`<h3>[${newArr2}]</h3>`);

    // ["Index 0: 10", "Index 1: 20", "Index 2: 30", "Index 3: 40", "Index 4: 50"]
    const numArr2 = [10, 20, 30, 40, 50];
    const newnumArr2 = numArr2.map(function (v, i, a) {
      return `" Index ${i}: ${v} "`;
    });
    document.write(`<h3>[${newnumArr2}]</h3>`);

    // ["김덕배", "최덕배", "이덕배"]
    const users2 = [
      { id: 1, name: "김덕배" },
      { id: 2, name: "최덕배" },
      { id: 3, name: "이덕배" },
    ];
    const newusers2 = users2.map(function (v, i, a) {
      return `" ${v.name} "`;
    });
    document.write(`<h3>[${newusers2}]</h3>`);

    // ['kim@gmail.com', 'choi@gmail.com', 'lee@gmail.com']
    const users3 = [
      { id: 1, name: "김덕배", contact: { email: "kim@gmail.com" } },
      { id: 2, name: "최덕배", contact: { email: "choi@gmail.com" } },
      { id: 3, name: "이덕배", contact: { email: "lee@gmail.com" } },
    ];
    const newusers3 = users3.map(function (v, i, a) {
      // let userContact = v.contact;
      // return userContact.email;
      return `" ${v.contact.email} "`;
    });
    document.write(`<h3>[${newusers3}]</h3>`);

    // [1, 2, 3],
    // [4, 5, 6],
    // [7, 8, 9],
    // 결과
    // [
    //   [2,  4,   6],
    //   [8,  10, 12],
    //   [14, 16, 18]
    // ]

    // const newDoubleArr = doubleArr.map(function (v, i, a) {
    //   const tempArr = [];
    //   for (let i = 0; i < v.length; i++) {
    //     tempArr.push(v[i] * 2);
    //   }
    //   return tempArr;
    // });
    const newDoubleArr = doubleArr.map(function (v, i, a) {
      return v.map(function (v, i, a) {
        return v * 2;
      });
    });
    document.write(`<h3>[${newDoubleArr}]</h3>`);
    console.log(newDoubleArr);

    // 3.filter() 함수 ⭐⭐⭐⭐
    // 배열의 모든 요소에 대하여 반복적으로 명시된 함수를 실행한 후,
    // 그 결과값이 true인 요소들만을 새로운 배열로 반환한다.
    // map 함수에  if절이 들어있다.
    document.write(`<h1>3. filter() 함수</h1>`);
    const numberArr2 = [1, 2, 3, 4, 5];
    let result = [];

    // for (let i = 0; i < numberArr2.length; i++) {
    //   if (numberArr2[i] > 3) {
    //     result.push(numberArr2[i]);
    //   }
    // }

    result = numberArr2.filter(function (v, i, a) {
      return v > 3;
    });
    document.write(`<h3>numberArr2 : [${numberArr2}]</h3>`);
    document.write(`<h3>[${result}]</h3>`);

    const guys = [
      { name: "덕배", money: 500000 },
      { name: "배컴", money: 700000 },
      { name: "홀란드", money: 600000 },
      { name: "포든", money: 400000 },
    ];
    // 500000보다 큰 배열
    const guysArr = guys.filter(function (v) {
      console.log(v.money > 500000);
      console.log(v);
      return v.money > 500000;
    });
    console.log(guysArr);

    // money > 500000, name =="홀란드"
    const guysArr1 = guys.filter(function (v) {
      // console.log(v.money > 500000);
      // console.log(v.name == "홀란드");
      // console.log(v.name == "홀란드" && v.money > 500000);
      console.log(v.name == "홀란드" || v.money > 500000);
      console.log(v);
      return v.name == "홀란드" && v.money > 500000;
    });
    console.log(guysArr1);

    // 4.reduce() 함수
    // 해당배열의 모든요소를 하나의 값으로 줄이기 위해
    // 두개의 인수를 전달받는 함수를 실행한다.
    // 이때, 명시된 함수에 배열의 첫번째 요소와 두번째 요소를 인수로 전달하고 실행된다.
    // 그 결과, 반환된 결과값에 세번째 요소를 다시 인수로 전달하고 실행된다.
    document.write(`<h1>4. reduce() 함수</h1>`);
    const numArr3 = [1, 2, 3, 4, 5];
    const result2 = numArr3.reduce(function (x, y) {
      return x + y;
    });
    // 1(x) + 2(y) 결과 값은 x로 들어가고 y는 3이 들어온다. 반복!
    document.write(`<h3>원본배열 : [${numArr3}]</h3>`);
    document.write(`<h3>reduce 결과 : [${result2}]</h3>`);

    const result3 = numArr3.reduce(function (x, y) {
      return x - y;
    });
    // 1-2-3-4-5 = -13
    document.write(`<h3>reduce 결과 : [${result3}]</h3>`);

    // 1. accmulateor : 누산기, 누적값
    // 2. currentValue: 처리할 현재요소
    // 3. currentIndex: 처리할 연재 요소의 인덱스
    // 4. array       : 대상 배열 전체
    // Array.reduce(function(acc, cur, cid, arr){}, initialValue)
    // initialValue이 없으면 처음부터 주어지면 x(acc)로 들어간 다음 순서대로 진행.

    // 5. reduceRight()함수
    // reduce() 함수와 같은 방식으로 실행되며,
    // 배열의 마지막 요소부터 줄이기 시작한다.
    const result4 = numArr3.reduceRight(function (x, y) {
      return x - y;
    });
    document.write(`<h3>reduceRight 결과 : [${result4}]</h3>`);
    // 5-4-3-2-1
  </script>
</html>
